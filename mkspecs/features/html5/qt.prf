
qt_depends = $$resolve_depends(QT, "QT.")
!watchos:equals(TEMPLATE, app):contains(qt_depends, gui(-private)?) {
    LIBS *= -L$$[QT_INSTALL_PLUGINS/get]/platforms

    lib_name = html5
    lib_path_and_base = $$[QT_INSTALL_PLUGINS/get]/platforms/lib$${lib_name}$$qtPlatformTargetSuffix()
    LIBS += -l$${lib_name}$$qtPlatformTargetSuffix() $$fromfile($${lib_path_and_base}.prl, QMAKE_PRL_LIBS)


}

load(qt)

## taken from qt.prf
import_plugins {
    manualplugs = $$QTPLUGIN  # User may specify plugins. Mostly legacy.
    autoplugs =  # Auto-added plugins.
    # First round: explicitly specified modules.
    plugin_deps = $$all_qt_module_deps
    for(ever) {
        # Automatically link the default plugins for the linked Qt modules.
        for (qtmod, plugin_deps) {
            for (ptype, QT.$${qtmod}.plugin_types) {
                nptype = $$replace(ptype, [-/], _)
                isEmpty(QTPLUGIN.$$nptype) {
                    for (plug, QT_PLUGINS) {
                        equals(QT_PLUGIN.$${plug}.TYPE, $$ptype) {
                            for (dep, QT_PLUGIN.$${plug}.EXTENDS) {
                                !contains(all_qt_module_deps, $$dep) {
                                    plug =
                                    break()
                                }
                            }
                            autoplugs += $$plug
                        }
                    }
                } else {
                    plug = $$eval(QTPLUGIN.$$nptype)
                    !equals(plug, -): \
                        autoplugs += $$plug
                }
            }
        }
        QTPLUGIN = $$manualplugs $$autoplugs
        QTPLUGIN = $$unique(QTPLUGIN)

        # Obtain the plugins' Qt dependencies ...
        plugin_deps =
        for (plug, QTPLUGIN): \
            plugin_deps += $$eval(QT_PLUGIN.$${plug}.DEPENDS)
        plugin_deps = $$resolve_depends(plugin_deps, "QT.", ".depends" ".run_depends")
        plugin_deps -= $$all_qt_module_deps
        isEmpty(plugin_deps): \
            break()
        # ... and start over if any new Qt modules appeared,
        # as these may want to load plugins in turn.
        all_qt_module_deps += $$plugin_deps
    }
    extraplugs = $$manualplugs
    manualplugs -= $$autoplugs
    extraplugs -= $$manualplugs
    !isEmpty(extraplugs): \
        warning("Redundant entries in QTPLUGIN: $$extraplugs")

    !isEmpty(QTPLUGIN) {
        IMPORT_FILE_CONT = \
            "// This file is autogenerated by qmake. It imports static plugin classes for" \
            "// static plugins specified using QTPLUGIN and QT_PLUGIN_CLASS.<plugin> variables." \
            "$${LITERAL_HASH}include <QtPlugin>"
        for (plug, QTPLUGIN) {
            plug_class = $$eval(QT_PLUGIN.$${plug}.CLASS_NAME)
            !isEmpty(plug_class): \
                IMPORT_FILE_CONT += "Q_IMPORT_PLUGIN($$plug_class)"
            else: \
                warning("Plugin class name could not be determined for plugin '$$plug'.")
        }
        IMPORT_CPP = $$OUT_PWD/$$lower($$basename(TARGET))_plugin_import.cpp
        write_file($$IMPORT_CPP, IMPORT_FILE_CONT)|error()
        GENERATED_SOURCES += $$IMPORT_CPP
        QMAKE_DISTCLEAN += $$IMPORT_CPP
    }
}
